# Formal Control of LLM Interaction Behavior Based on DES

## Project Overview

This project demonstrates how to use **Discrete Event System (DES)** controllers to dynamically constrain the action space of Large Language Models (LLMs) at runtime through formal methods, ensuring that LLM behavior complies with predefined specifications and constraints.

## Application Scenario

**Technical Support Robot**: A customer service scenario that requires following specific procedures
- Must collect user information before escalating issues
- Must handle user requests according to standardized processes
- Prevents LLM from generating behaviors that violate business rules

## Core Concepts

### DES (Discrete Event System)
- **Plant (G)**: Describes all possible behaviors and state transitions of the system
- **Specification (E)**: Defines constraints and specifications that the system must comply with
- **Supervisor (C)**: A controller synthesized through supervisory control theory that ensures system behavior complies with specifications

### Event Types
- **Controllable Events ('c')**: Events that the system can choose whether to execute (e.g., Prompts)
- **Uncontrollable Events ('u')**: Events that the system cannot prevent (e.g., LLM/User Responses)

## Project Structure

```
tct/
├── README                          # This file
├── llm_control_tct.ipynb          # Version with DES controller (Recommended)
├── llm_tct.ipynb                  # Baseline version without controller (Comparison experiment)
└── llm_controller_project/        # Working directory generated by pitct
```

## File Descriptions

### 1. llm_control_tct.ipynb
**LLM Interaction Version with DES Controller**

Contains the complete formal modeling process:
- **Phase 0**: Project setup and initialization
- **Phase 1**: Scenario definition and Plant modeling (G)
  - Define states: Idle, Problem Received, Info Gathering, Solution Proposed, Escalated, Resolved
  - Define events: Prompts (controllable), User/LLM Responses (uncontrollable)
  - Build state transition diagram
- **Phase 2**: Specification definition (E) - Define constraints that must be followed
- **Phase 3**: Supervisor synthesis (C) - Automatically generate controller
- **Phase 4**: Runtime control - Apply controller in LLM interactions

**Key Features**:
- Formal guarantee that LLM behavior complies with specifications
- Dynamically constrain available action space at runtime
- Verifiable safety and compliance

### 2. llm_tct.ipynb
**Baseline Version without Controller (Comparison Experiment)**

Demonstrates potential violations that LLM may produce without formal control:
- LLM can freely choose any action
- May escalate issues before collecting information
- May violate business process specifications

**Purpose**: Serves as a comparison experiment to demonstrate the necessity and effectiveness of DES controllers

## Tech Stack

- **pitct**: Python TCT library for discrete event system modeling and supervisory controller synthesis
- **Python**: Primary programming language
- **Jupyter Notebook**: Interactive development environment

## Quick Start

### Environment Setup
```bash
pip install pitct
```

### Running Examples

1. **Run version with controller** (Recommended):
   ```bash
   jupyter notebook llm_control_tct.ipynb
   ```

2. **Run comparison experiment** (without controller):
   ```bash
   jupyter notebook llm_tct.ipynb
   ```

## Workflow

```
1. Define Plant (G) - All possible behaviors
   ↓
2. Define Specification (E) - Constraint specifications
   ↓
3. Synthesize Supervisor (C) - Automatically generate controller
   ↓
4. Runtime control - Constrain LLM action space
   ↓
5. Ensure compliance - Formal verification
```

## State Definitions

| State ID | State Name | Description |
|--------|---------|------|
| 0 | S0_Idle | Idle state |
| 1 | S1_ProblemReceived | Problem received |
| 2 | S2_InfoGathering | Gathering information |
| 3 | S3_SolutionProposed | Solution proposed |
| 4 | S4_Escalated | Escalated to human |
| 5 | S5_Resolved | Problem resolved |

## Event Definitions

### Controllable Events (Prompts)
- `p_ask_problem`: Ask user about the problem
- `p_ask_details`: Ask for detailed information
- `p_escalate`: Escalate the issue
- `p_end_session`: End the session

### Uncontrollable Events (Responses)
- `r_provides_info`: User provides information
- `r_confirms_solved`: User confirms problem is solved
- `r_requests_escalation`: User requests escalation
- `r_is_confused`: User/LLM expresses confusion

## Core Advantages

1. **Formal Guarantee**: Use mathematical methods to prove correctness of system behavior
2. **Runtime Control**: Dynamically constrain available LLM actions to prevent violations
3. **Verifiability**: Can verify whether the system satisfies all specifications
4. **Extensibility**: Easy to add new constraints and specifications
5. **Transparency**: Clearly shows why certain actions are prohibited

## Extended Application Scenarios

This method can be applied to any scenario requiring LLM behavior constraints:
- Financial services (compliance requirements)
- Medical consultation (safety requirements)
- Legal consultation (professional requirements)
- Educational tutoring (teaching process requirements)
- Industrial control (safety-critical systems)


## Contributing

Issues and Pull Requests are welcome!
